(1)Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?

answers：函数的参数寄存器为a0~a7；main中printf的参数13保存在a2中

(2)Where is the call to function f in the assembly code for main? Where is the call to g?

answers：并没有直接的调用，g(x)被内联到了f(x)中（相当于代码直接插入，而非函数调用），而f(x)又被内联到了main中

(3)At what address is the function printf located?

answers：注释中已经写出来了，就是0x630

(4)What value is in the register ra just after the jalr to printf in main?

answers：使用jalr跳转printf后，需要保存返回地址到ra，以供printf结束后回到main继续执行指令。
所以jalr会将PC+4，也就是下一条指令的地址存入ra中。
当前PC指向0x34，故ra=PC+4=0x38

(5)Run the following code.

	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);
      
What is the output? Here's an ASCII table that maps bytes to characters.
The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?

answers：57616 = 0xe110；0x00646c72小端存储为72-6c-64-00，对照ASCII码表转为字符
72:r，6c:l，64:d，00:充当字符串结尾标识
故输出：He110 World
若为大端存储，i应颠倒为0x726c6400，不需改变57616

(6)In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?

	printf("x=%d y=%d", 3);

answers：根据call的汇编代码
li	a2,13
li	a1,12
可以看出，printf的参数从a1、a2……中取，所以这里应该也是a2寄存器中的值
      